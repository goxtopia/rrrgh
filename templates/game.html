<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>迷雾港口 | Mist Harbor</title>
    <link rel="stylesheet" href="{{ url_for('static', filename='style.css') }}">
</head>
<body>
    <div class="crt-overlay"></div>
    <div class="scanlines"></div>

    <div class="container">
        <header>
            <h1>MIST HARBOR</h1>
            <div id="stats-bar">
                <span id="sanity-display">SANITY: 100%</span> |
                <span id="stats-display">STR: 10 DEX: 10 INT: 10 CHA: 10</span> |
                <span id="inventory-display">INV: []</span>
            </div>
        </header>

        <main id="game-area">
            <div id="visual-display" class="visual-art"></div>
            <div id="text-display" class="typewriter"></div>
            <div id="choices-container">
                <button onclick="showModeSelect()">START GAME</button>
            </div>
        </main>
    </div>

    <!-- Mode Select Modal -->
    <div id="mode-select" class="modal" style="display:none;">
        <div class="modal-content">
            <h2>SELECT GAME MODE</h2>
            <button onclick="startStoryMode()">STORY MODE (Classic)</button>
            <button onclick="showLiveSetup()">LIVE MODE (AI GM)</button>
            <button onclick="closeModal()">CANCEL</button>
        </div>
    </div>

    <!-- Live Setup Modal -->
    <div id="live-setup" class="modal" style="display:none;">
        <div class="modal-content">
            <h2>LIVE MODE SETUP</h2>
            <div class="input-group">
                <label>API Key (OpenAI Compatible):</label>
                <input type="password" id="api-key" placeholder="sk-...">
            </div>
            <div class="input-group">
                <label>Endpoint URL:</label>
                <input type="text" id="endpoint" value="https://api.openai.com/v1">
            </div>
            <div class="input-group">
                <label>Model:</label>
                <input type="text" id="model" value="gpt-3.5-turbo">
            </div>
            <div class="input-group">
                <label>World Context (Optional):</label>
                <textarea id="world-prompt" placeholder="Leave empty for default Mist Harbor..."></textarea>
            </div>
            <button onclick="startLiveMode()">BEGIN SESSION</button>
            <button onclick="closeModal()">CANCEL</button>
        </div>
    </div>

    <script>
        let isTyping = false;
        let typingTimer = null;

        function showModeSelect() {
            document.getElementById('mode-select').style.display = 'flex';
        }

        function showLiveSetup() {
            document.getElementById('mode-select').style.display = 'none';
            document.getElementById('live-setup').style.display = 'flex';
        }

        function closeModal() {
            document.getElementById('mode-select').style.display = 'none';
            document.getElementById('live-setup').style.display = 'none';
        }

        async function startStoryMode() {
            closeModal();
            const response = await fetch('/start', { method: 'POST' });
            const data = await response.json();
            updateUI(data);
        }

        async function startLiveMode() {
            const apiKey = document.getElementById('api-key').value;
            const endpoint = document.getElementById('endpoint').value;
            const model = document.getElementById('model').value;
            const worldPrompt = document.getElementById('world-prompt').value;

            closeModal();

            // Show loading state
            document.getElementById('text-display').innerText = "Connecting to the Keeper...";

            const response = await fetch('/live/setup', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    api_key: apiKey,
                    endpoint: endpoint,
                    model: model,
                    world_prompt: worldPrompt
                })
            });
            const data = await response.json();
            updateUI(data);
        }

        async function makeChoice(index) {
            if (isTyping) {
                // Instantly finish typing (optional feature for impatient players)
                // For now, let's just ignore clicks while typing or allow instant display
            }
            const response = await fetch('/choice', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ index: index })
            });

            if (response.ok) {
                const data = await response.json();
                updateUI(data);
            } else {
                console.error('Error making choice');
            }
        }

        function updateUI(data) {
            // Clear any existing typing timer
            if (typingTimer) {
                clearTimeout(typingTimer);
                typingTimer = null;
            }

            // Update Stats
            document.getElementById('sanity-display').innerText = `SANITY: ${data.stats.sanity}%`;

            if (data.stats.attributes) {
                const attrs = data.stats.attributes;
                document.getElementById('stats-display').innerText =
                    `STR: ${attrs.str || 10} DEX: ${attrs.dex || 10} INT: ${attrs.int || 10} CHA: ${attrs.cha || 10}`;
            }

            const invText = data.stats.inventory.length > 0 ? data.stats.inventory.join(', ') : 'EMPTY';
            document.getElementById('inventory-display').innerText = `INV: [${invText}]`;

            // Update Visual
            const visualDiv = document.getElementById('visual-display');
            visualDiv.innerText = data.visual;
            visualDiv.classList.remove('glitch');
            void visualDiv.offsetWidth; // trigger reflow
            visualDiv.classList.add('glitch');

            // Remove glitch class after animation finishes to restore pulse
            setTimeout(() => {
                visualDiv.classList.remove('glitch');
            }, 300);

            // Update Text (Typewriter effect)
            const textDiv = document.getElementById('text-display');
            textDiv.innerHTML = '';

            let fullText = data.text;
            if (data.roll_message) {
                fullText = data.roll_message + "\n\n" + fullText;
            }

            typeWriter(fullText, textDiv);

            // Update Choices
            const choicesDiv = document.getElementById('choices-container');
            choicesDiv.innerHTML = '';

            // We delay showing choices until typing is done?
            // For responsiveness, let's show them immediately but maybe fade in.
            data.choices.forEach(choice => {
                const btn = document.createElement('button');
                btn.innerText = `> ${choice.text}`;
                btn.onclick = () => makeChoice(choice.index);
                choicesDiv.appendChild(btn);
            });
        }

        function typeWriter(text, element) {
            isTyping = true;
            let i = 0;
            const speed = 30;

            function type() {
                if (i < text.length) {
                    if (text.charAt(i) === '\n') {
                        element.innerHTML += '<br>';
                    } else {
                        element.innerHTML += text.charAt(i);
                    }
                    i++;
                    typingTimer = setTimeout(type, speed);
                } else {
                    isTyping = false;
                    typingTimer = null;
                }
            }
            type();
        }
    </script>
</body>
</html>